<!DOCTYPE html>
<html>
  <head lang="en">
    <meta charset="utf-8" />
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
      #controls {
        position: fixed;
        bottom: 10px;
        left: 10px;
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }
      #controls button {
        padding: 10px;
        font-size: 14px;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
  </head>
  <body>
    <div id="arm"></div>
    <div id="controls">
      <button onclick="selectRobot(0)">Robot 0</button>
      <button onclick="selectRobot(1)">Robot 1</button>
      <button onclick="setCameraMode('S')">Superior</button>
      <button onclick="setCameraMode('P')">Primera</button>
      <button onclick="setCameraMode('T')">Tercera</button>
      <button onclick="setCameraMode('B')">Brazo</button>
    </div>

    <script>
      class Robot {
        constructor(scene, options = {}) {
          this.state = {
            x: options.x ?? 0,
            y: options.y ?? 0,
            beta: options.beta ?? 0,
            alpha0: options.alpha0 ?? 0,
            alpha1: options.alpha1 ?? 0,
            alpha2: options.alpha2 ?? 0,
          };

          this.group = new THREE.Group();
          scene.add(this.group);

          this._build();

          this.sequence = [];
          this.currentStep = null;
          this.timeLeft = 0;
          this.initialAngles = {};
        }

        _build() {
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.5, 2),
            new THREE.MeshBasicMaterial({ color: 0x0077ff })
          );
          this.group.add(base);
          this.base = base;

          const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 32);
          const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });

          const wheelOffsets = [
            [0.7, 0, 1.2],
            [0.7, 0, -1.2],
            [-0.7, 0, 1.2],
            [-0.7, 0, -1.2],
          ];

          wheelOffsets.forEach(([x, y, z]) => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.x = Math.PI / 2;
            wheel.position.set(x, y, z);
            this.group.add(wheel);
          });

          const color_brazo = 0x00fff0;
          const a1 = 0.5;
          const a2 = 1;
          const a3 = 1;

          let geometry = new THREE.BoxGeometry(0.5, a1, 0.5);
          let material = new THREE.MeshBasicMaterial({ color: color_brazo });
          const armBase = new THREE.Mesh(geometry, material);
          armBase.translateY(a1 / 2);
          base.add(armBase);
          this.armBase = armBase;

          let shoulder = new THREE.Object3D();
          shoulder.translateY(a1 / 2);
          armBase.add(shoulder);
          this.shoulder = shoulder;

          geometry = new THREE.BoxGeometry(a2, 0.2, 0.2);
          let lowerArm = new THREE.Mesh(geometry, material);
          lowerArm.translateX(a2 / 2);
          shoulder.add(lowerArm);

          let elbow = new THREE.Object3D();
          elbow.translateX(a2 / 2);
          lowerArm.add(elbow);
          this.elbow = elbow;

          geometry = new THREE.BoxGeometry(a3, 0.1, 0.1);
          let arm = new THREE.Mesh(geometry, material);
          arm.translateX(a3 / 2);
          elbow.add(arm);

          let wrist = new THREE.Object3D();
          wrist.translateX(a3 / 2);
          arm.add(wrist);

          geometry = new THREE.TorusGeometry(0.1, 0.01, 3, 9, 5.6);
          let hand = new THREE.Mesh(geometry, material);
          hand.rotation.y = Math.PI / 2;
          hand.rotation.x = Math.PI / 2;
          wrist.add(hand);
        }

        moveTo(delta = {}) {
          Object.entries(delta).forEach(([key, value]) => {
            if (this.state.hasOwnProperty(key)) {
              this.state[key] += value;
            }
          });
        }

        setSequence(sequence) {
          this.sequence = sequence;
          this.currentStep = null;
          this.timeLeft = 0;
        }

        _startNextStep() {
          if (this.sequence.length === 0) {
            this.currentStep = null;
            return;
          }
          this.currentStep = this.sequence.shift();
          this.timeLeft = this.currentStep.time;

          this.initialAngles = {
            alpha0: this.state.alpha0,
            alpha1: this.state.alpha1,
            alpha2: this.state.alpha2,
          };
        }

        update(deltaTime) {
          if (!this.currentStep) {
            this._startNextStep();
            if (!this.currentStep) {
              this._render();
              return;
            }
          }

          const {
            x = this.state.x,
            y = this.state.y,
            beta = this.state.beta,
            v = this.state.v,
            w = this.state.w,
            alpha0 = this.state.alpha0,
            alpha1 = this.state.alpha1,
            alpha2 = this.state.alpha2,
          } = this.currentStep;

          this.state.x += v * Math.cos(this.state.beta) * deltaTime;
          this.state.y -= v * Math.sin(this.state.beta) * deltaTime;
          this.state.beta += (this.currentStep.w ?? 0) * deltaTime;

          const t = 1 - this.timeLeft / this.currentStep.time;

          ["alpha0", "alpha1", "alpha2"].forEach((key) => {
            if (this.currentStep[key] !== undefined) {
              const start = this.initialAngles[key];
              const end = this.currentStep[key];
              this.state[key] = start + (end - start) * t;
            }
          });

          this.timeLeft -= deltaTime;
          if (this.timeLeft <= 0) {
            this._startNextStep();
          }

          this._render();
        }

        _render() {
          this.group.position.set(this.state.x, 0, this.state.y);
          this.group.rotation.y = this.state.beta;

          this.armBase.rotation.y = this.state.alpha0;
          this.shoulder.rotation.z = this.state.alpha1;
          this.elbow.rotation.z = this.state.alpha2 - this.state.alpha1;
        }
      }

      let selectedRobot = null;
      let cameraMode = "T";

      const width = window.innerWidth;
      const height = window.innerHeight / 2;
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf4f4f8);

      const camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 1000);
      camera.position.set(0, 25, 25);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(width, height);
      document.getElementById("arm").appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0x888888);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 10, 7);
      scene.add(dir);

      const grid = new THREE.GridHelper(60, 60);
      scene.add(grid);

      const n_bots = 10;
      const robots = [];

      const beat = 1;
      const n_beats = 5;
      const tiempo = n_beats * beat;
      const d = 1;
      const R = 2.5;
      const omega = Math.PI / tiempo;
      const vel_lin = omega * R;

      for (let i = 0; i < n_bots; i++) {
        const robot = new Robot(scene, { x: (i - n_bots / 2) * 5, y: 0 });

        if (i % 2 == 0) {
          robot.setSequence([
            { v: 1, w: 0, alpha0: 0, time: 2 },
            { v: 0, w: -Math.PI / 4, alpha0: -Math.PI / 2, alpha1: 0, time: 2 },
            { v: vel_lin, w: omega, time: tiempo },
            {
              v: 0,
              w: 0,
              alpha0: Math.PI / 2,
              alpha1: (6 * Math.PI) / 16,
              alpha2: -(6 * Math.PI) / 16,
              time: 2,
            },
            { v: -vel_lin, w: omega, time: tiempo },
          ]);
        } else {
          robot.setSequence([
            { v: 1, w: 0, alpha0: 0, time: 2 },
            {
              v: 0,
              w: -Math.PI / 4,
              alpha0: Math.PI / 2,
              alpha1: (6 * Math.PI) / 16,
              alpha2: -(6 * Math.PI) / 16,
              time: 2,
            },
            { v: -vel_lin, w: omega, time: tiempo },
            { v: 0, w: 0, alpha0: -Math.PI / 2, alpha1: 0, alpha2: 0, time: 2 },
            { v: vel_lin, w: omega, time: tiempo },
          ]);
        }
        robots.push(robot);
      }

      let lastTime = performance.now();
      const keys = {};

      window.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code.startsWith("Digit")) {
          const idx = parseInt(e.code.replace("Digit", ""));
          if (robots[idx]) {
            selectedRobot = robots[idx];
            console.log(`Robot ${idx} seleccionado`);
          }
        }
        if (["KeyS", "KeyP", "KeyT", "KeyB"].includes(e.code)) {
          cameraMode = e.code.replace("Key", "");
          console.log(`Modo de cÃ¡mara: ${cameraMode}`);
        }
      });

      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      const cameraSpeed = 0.01;
      const rotationSpeed = 0.002;

      animate();
      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaTime = (now - lastTime) / 1000;
        lastTime = now;

        handleCameraControls();
        for (const robot of robots) robot.update(deltaTime);

        updateCameraView();
        renderer.render(scene, camera);
      }

      function selectRobot(idx) {
        if (robots[idx]) {
          selectedRobot = robots[idx];
          console.log("Robot " + idx + " selected");
        }
      }

      function setCameraMode(mode) {
        cameraMode = mode;
        console.log("Camera mode " + mode);
      }

      function updateCameraView() {
        if (!selectedRobot) return;
        const target = selectedRobot.group.position.clone();

        switch (cameraMode) {
          case "S":
            camera.position.set(target.x, 10, target.z);
            camera.lookAt(target);
            break;
          case "P": {
            const dir = new THREE.Vector3(
              -Math.sin(selectedRobot.state.beta),
              0,
              -Math.cos(selectedRobot.state.beta)
            );
            const eye = target.clone().add(new THREE.Vector3(0, 1.5, 0));
            const lookAt = eye.clone().add(dir);
            camera.position.copy(eye);
            camera.lookAt(lookAt);
            break;
          }
          case "T": {
            const dir = new THREE.Vector3(
              -Math.sin(selectedRobot.state.beta),
              0,
              -Math.cos(selectedRobot.state.beta)
            );
            const eye = target
              .clone()
              .add(new THREE.Vector3(0, 2, 0))
              .sub(dir.multiplyScalar(5));
            camera.position.copy(eye);
            camera.lookAt(target.clone().add(new THREE.Vector3(0, 1, 0)));
            break;
          }
          case "B": {
            camera.position.x =
              Math.cos(
                selectedRobot.armBase.rotation.y +
                  selectedRobot.base.rotation.y
              ) * 2;
            camera.position.z =
              Math.sin(
                selectedRobot.armBase.rotation.y +
                  selectedRobot.base.rotation.y
              ) * 2;
            camera.position.y = selectedRobot.armBase.position.y + 2;
            camera.lookAt(
              selectedRobot.armBase.getWorldPosition(new THREE.Vector3())
            );
            break;
          }
        }
      }

      function handleCameraControls() {
        if (keys["KeyW"]) {
          camera.position.x -= Math.sin(camera.rotation.y) * cameraSpeed;
          camera.position.z -= Math.cos(camera.rotation.y) * cameraSpeed;
        }
        if (keys["KeyS"]) {
          camera.position.x += Math.sin(camera.rotation.y) * cameraSpeed;
          camera.position.z += Math.cos(camera.rotation.y) * cameraSpeed;
        }
        if (keys["KeyA"]) {
          camera.position.x -= Math.cos(camera.rotation.y) * cameraSpeed;
          camera.position.z += Math.sin(camera.rotation.y) * cameraSpeed;
        }
        if (keys["KeyD"]) {
          camera.position.x += Math.cos(camera.rotation.y) * cameraSpeed;
          camera.position.z -= Math.sin(camera.rotation.y) * cameraSpeed;
        }
        if (keys["ArrowLeft"]) camera.rotation.y += rotationSpeed;
        if (keys["ArrowRight"]) camera.rotation.y -= rotationSpeed;
        if (keys["ArrowUp"]) camera.rotation.x += rotationSpeed;
        if (keys["ArrowDown"]) camera.rotation.x -= rotationSpeed;
        if (keys["KeyI"]) camera.position.y += cameraSpeed * 5;
        if (keys["KeyK"]) camera.position.y -= cameraSpeed * 5;
        if (keys["KeyJ"]) camera.position.x -= cameraSpeed;
        if (keys["KeyL"]) camera.position.x += cameraSpeed;
      }
    </script>
  </body>
</html>
