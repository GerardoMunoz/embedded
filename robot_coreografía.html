<!DOCTYPE html>
<html>

<head lang="en">
  <meta charset="utf-8" />
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
    }

    #controls {
      position: fixed;
      bottom: 10px;
      left: 10px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
    }

    #controls button {
      padding: 10px;
      font-size: 14px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/build/three.min.js"></script>
</head>

<body>
  <div id="render1"></div>
  <div id="render2"></div>
  <div id="controls">
    <button onclick="coreografia()">Coreografía</button>
    <button onclick="selectRobot(0)">Robot 0</button>
    <button onclick="selectRobot(1)">Robot 1</button>
    <button onclick="setCameraMode('S')">Superior</button>
    <button onclick="setCameraMode('P')">Primera</button>
    <button onclick="setCameraMode('T')">Tercera</button>
    <button onclick="setCameraMode('B')">Brazo</button>
  </div>
  <audio id="music" src="ymca.mp3"></audio>

  <script>
    const music = document.getElementById("music");
    //music.volume = 0.7;
    //music.currentTime = 60; // minuto 1
    //music.play();
    //setTimeout(() => audio.pause(), 120000);7


    class Robot {
      constructor(scene, options = {}) {
        this.state = {
          x: options.x ?? 0,
          y: options.y ?? 0,
          beta: options.beta ?? 0,
          alpha0: options.alpha0 ?? 0,
          alpha1: options.alpha1 ?? 0,
          alpha2: options.alpha2 ?? 0,
        };

        this.group = new THREE.Group();
        scene.add(this.group);

        this._build();

        this.sequence = [];
        this.currentStep = null;
        this.timeLeft = 0;
        this.initialAngles = {};
      }

      _build() {
        const base = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.5, 2),//(1, 0.3, .8),
          new THREE.MeshBasicMaterial({ color: 0x0077ff })
        );
        base.position.y = 0.3
        this.group.add(base);
        this.base = base;

        const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 32);//(0.2, 0.2, 0.3, 32);
        const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });

        const wheelOffsets = [
          [0.7, 0.4, 1.2],
          [0.7, 0.4, -1.2],
          [-0.7, 0.4, 1.2],
          [-0.7, 0.4, -1.2],
        ];

        // const wheelOffsets = [
        //   [0.4, 0, 0.6],
        //   [0.4, 0, -0.6],
        //   [-0.4, 0, 0.6],
        //   [-0.4, 0, -0.6],
        // ];

        wheelOffsets.forEach(([x, y, z]) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.rotation.x = Math.PI / 2;
          wheel.position.set(x, y, z);
          this.group.add(wheel);
        });

        const color_brazo = 0x00fff0;
        const a1 = 0.5;
        const a2 = 1;
        const a3 = 1;

        let geometry = new THREE.BoxGeometry(0.5, a1, 0.5);
        let material = new THREE.MeshBasicMaterial({ color: color_brazo });
        const armBase = new THREE.Mesh(geometry, material);
        armBase.translateY(a1 / 2);
        armBase.translateX(0.6);
        base.add(armBase);
        this.armBase = armBase;

        let shoulder = new THREE.Object3D();
        shoulder.translateY(a1 / 2);
        armBase.add(shoulder);
        this.shoulder = shoulder;

        geometry = new THREE.BoxGeometry(a2, 0.2, 0.2);
        let lowerArm = new THREE.Mesh(geometry, material);
        lowerArm.translateX(a2 / 2);
        shoulder.add(lowerArm);

        let elbow = new THREE.Object3D();
        elbow.translateX(a2 / 2);
        lowerArm.add(elbow);
        this.elbow = elbow;

        geometry = new THREE.BoxGeometry(a3, 0.1, 0.1);
        let arm = new THREE.Mesh(geometry, material);
        arm.translateX(a3 / 2);
        elbow.add(arm);

        let wrist = new THREE.Object3D();
        wrist.translateX(a3 / 2);
        arm.add(wrist);

        geometry = new THREE.TorusGeometry(0.1, 0.01, 3, 9, 5.6);
        let hand = new THREE.Mesh(geometry, material);
        hand.rotation.y = Math.PI / 2;
        hand.rotation.x = Math.PI / 2;
        wrist.add(hand);
      }

      moveTo(delta = {}) {
        Object.entries(delta).forEach(([key, value]) => {
          if (this.state.hasOwnProperty(key)) {
            this.state[key] += value;
          }
        });
      }

      setSequence(sequence) {
        this.sequence = sequence;
        this.currentStep = null;
        this.timeLeft = 0;
      }

      _startNextStep() {
        if (this.sequence.length === 0) {
          this.currentStep = null;
          return;
        }
        this.currentStep = this.sequence.shift();
        this.timeLeft = this.currentStep.time;

        this.initialAngles = {
          alpha0: this.state.alpha0,
          alpha1: this.state.alpha1,
          alpha2: this.state.alpha2,
        };
      }

      update(deltaTime) {
        if (!this.currentStep) {
          this._startNextStep();
          if (!this.currentStep) {
            this._render();
            return;
          }
        }

        const {
          x = this.state.x,
          y = this.state.y,
          beta = this.state.beta,
          v = this.state.v,
          w = this.state.w,
          alpha0 = this.state.alpha0,
          alpha1 = this.state.alpha1,
          alpha2 = this.state.alpha2,
        } = this.currentStep;

        this.state.x += v * Math.cos(this.state.beta) * deltaTime;
        this.state.y -= v * Math.sin(this.state.beta) * deltaTime;
        this.state.beta += (this.currentStep.w ?? 0) * deltaTime;

        const t = 1 - this.timeLeft / this.currentStep.time;

        ["alpha0", "alpha1", "alpha2"].forEach((key) => {
          if (this.currentStep[key] !== undefined) {
            const start = this.initialAngles[key];
            const end = this.currentStep[key];
            this.state[key] = start + (end - start) * t;
          }
        });

        this.timeLeft -= deltaTime;
        if (this.timeLeft <= 0) {
          this._startNextStep();
        }

        this._render();
      }

      _render() {
        this.group.position.set(this.state.x, 0, this.state.y);
        this.group.rotation.y = this.state.beta;

        this.armBase.rotation.y = this.state.alpha0;
        this.shoulder.rotation.z = this.state.alpha1;
        this.elbow.rotation.z = this.state.alpha2 - this.state.alpha1;
      }
    }

    // Three.js

    let selectedRobot = null;
    let cameraMode = "P";

    const width = window.innerWidth;
    const height = window.innerHeight / 2;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf4f4f8);

    const camera1 = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera1.position.set(0, 25, 25);
    camera1.lookAt(0, 0, 0);

    const camera2 = new THREE.PerspectiveCamera(30, 320/240, 0.1, 1000);
    //camera2.position.set(0, 25, 25);
    //camera2.lookAt(0, 0, 0);

    const renderer1 = new THREE.WebGLRenderer();
    renderer1.setSize(width, height);
    document.getElementById("render1").appendChild(renderer1.domElement);
    const renderer2 = new THREE.WebGLRenderer();
    renderer2.setSize(320, 240);
    document.getElementById("render2").appendChild(renderer2.domElement);

    const ambient = new THREE.AmbientLight(0x888888);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7);
    scene.add(dir);


    ////////////////////////Escenario Piso, paredes 

    const corridorWidth = 60;    // decimetros
    const corridorLength = 200;  // decimetros
    const tileSize = 10 / 3;       // 3.333333... decimetros (exacto para 15x60)
    const tilesX = Math.round(corridorWidth / tileSize); // 15
    const tilesZ = Math.round(corridorLength / tileSize); // 60

    // número de variantes de textura procedural (menos repetición)
    const tileVariants = 10;

    const grid = new THREE.GridHelper(60, 20);//(tileSize, tileSize);
    scene.add(grid);

    scene.background = new THREE.Color(0xdbe8f2);



    function generateTileVariants(n, size = 256, chips = 150) {
      const arr = [];
      for (let k = 0; k < n; k++) {
        const c = document.createElement('canvas');
        c.width = c.height = size;
        const ctx = c.getContext('2d');

        // fondo cemento (ligeramente variable)
        const base = 220 + Math.floor((Math.random() - 0.5) * 18);
        ctx.fillStyle = `rgb(${base}, ${base}, ${base})`;
        ctx.fillRect(0, 0, size, size);

        // pintar chips (aleatorio)
        for (let i = 0; i < chips; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = 3 + Math.random() * 14;
          ctx.beginPath();
          // forma irregular simple con 5 vértices
          for (let p = 0; p < 5; p++) {
            const angle = (p / 5) * Math.PI * 2;
            const rr = r * (0.5 + Math.random() * 1.0);
            const px = x + Math.cos(angle) * rr;
            const py = y + Math.sin(angle) * rr;
            if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.closePath();

          // color de chip — gris/beige con ligera variación
          const gbase = 100 + Math.random() * 100;
          const rcol = Math.floor(gbase + (Math.random() - 0.5) * 30);
          const gcol = Math.floor(gbase + (Math.random() - 0.5) * 30);
          const bcol = Math.floor(gbase + (Math.random() - 0.5) * 30);
          ctx.fillStyle = `rgb(${rcol},${gcol},${bcol})`;
          ctx.fill();

          // opcional borde oscuro muy sutil para profundidad
          if (Math.random() < 0.12) {
            ctx.strokeStyle = "rgba(0,0,0,0.06)";
            ctx.lineWidth = Math.max(1, Math.random() * 2);
            ctx.stroke();
          }
        }

        // // brillo local: pinta un gradiente sutil para simular barniz desigual
        // const g = ctx.createLinearGradient(0, 0, size, size);
        // g.addColorStop(0, 'rgba(255,255,255,0.00)');
        // g.addColorStop(1, 'rgba(255,255,255,0.03)');
        // ctx.fillStyle = g;
        // ctx.fillRect(0,0,size,size);

        const tex = new THREE.CanvasTexture(c);
        tex.encoding = THREE.sRGBEncoding;
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1, 1);
        arr.push(tex);
      }
      return arr;
    }

    const variants = generateTileVariants(tileVariants);

    // ---------- crear piso con baldosas individuales ----------
    const floorGroup = new THREE.Group();
    floorGroup.name = "floorGroup";

    const tileGeo = new THREE.PlaneGeometry(tileSize, tileSize);
    // small offset so we can "see" joints (gap)
    const jointGap = 0.002; // 2mm gap between tiles
    const effectiveTile = tileSize - jointGap;

    for (let ix = 0; ix < tilesX; ix++) {
      for (let iz = 0; iz < tilesZ; iz++) {
        const variantIndex = Math.floor(Math.random() * variants.length);
        const tex = variants[variantIndex];

        // para menos repetición, rotamos la textura 0/90/180/270 aleatoriamente
        const rotation = Math.floor(Math.random() * 4) * (Math.PI / 2);
        // clonamos material por baldosa (se puede optimizar agrupando por variante)
        const mat = new THREE.MeshPhysicalMaterial({
          map: tex,
          roughness: 0.55 + Math.random() * 0.15,
          metalness: 0.0,
          clearcoat: 0.5,
          clearcoatRoughness: 0.08 + Math.random() * 0.08,
          side: THREE.DoubleSide
        });

        const tile = new THREE.Mesh(tileGeo, mat);
        tile.rotation.x = -Math.PI / 2;
        tile.position.x = (ix + 0.5) * tileSize - corridorWidth / 2;
        tile.position.z = (iz + 0.5) * tileSize - corridorLength / 2;
        tile.position.y = 0.0005; // elevar ligeramente para evitar z-fighting con base

        // aplicar rotación de UV a la textura: usamos rotation en la textura
        tex.center.set(0.5, 0.5);
        tex.rotation = rotation;

        // escalar ligeramente la malla para crear juntas visibles (no la textura)
        tile.scale.set(effectiveTile / tileSize, 1, effectiveTile / tileSize);

        tile.receiveShadow = true;
        floorGroup.add(tile);
      }
    }

    scene.add(floorGroup);







    // ---------- paredes ----------
    // // paredes como grandes planos verticales en los lados del corredor
    // const bhHeight = 3.0; // metros
    // const gbThickness = 0.1;
    // const bhMaterial = new THREE.MeshStandardMaterial({ color: 0xfff5e1 }); // crema

    // // pared izquierda
    // const bhWallGeo = new THREE.BoxGeometry(bhThickness, bhHeight, corridorLength + 0.2);
    // const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
    // leftWall.position.set(-corridorWidth/2 - wallThickness/2, wallHeight/2, 0);
    // leftWall.receiveShadow = true;
    // leftWall.castShadow = false;
    // scene.add(leftWall);

    // // pared derecha
    // const rightWallGeo = new THREE.BoxGeometry(wallThickness, wallHeight, corridorLength + 0.2);
    // const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
    // rightWall.position.set(corridorWidth/2 + wallThickness/2, wallHeight/2, 0);
    // rightWall.receiveShadow = true;
    // scene.add(rightWall);

    const wallHeight = 30.0; // decimetros
    const wallThickness = 0.5;
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xfff5e1 }); // crema

    // pared izquierda
    const leftWallGeo = new THREE.BoxGeometry(wallThickness, wallHeight, corridorLength + 0.2);
    const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
    leftWall.position.set(-corridorWidth / 2 - wallThickness / 2, wallHeight / 2, 0);
    leftWall.receiveShadow = true;
    leftWall.castShadow = false;
    scene.add(leftWall);

    // pared derecha
    const rightWallGeo = new THREE.BoxGeometry(wallThickness, wallHeight, corridorLength + 0.2);
    const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
    rightWall.position.set(corridorWidth / 2 + wallThickness / 2, wallHeight / 2, 0);
    rightWall.receiveShadow = true;
    scene.add(rightWall);

    // // techo (opcional) - para ver el brillo en contexto, use techo alto semi-transparente
    // const ceilingGeo = new THREE.PlaneGeometry(corridorWidth + 0.2, corridorLength + 0.2);
    // const ceilingMat = new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    // const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
    // ceiling.rotation.x = Math.PI/2;
    // ceiling.position.y = wallHeight + 0.01;
    // scene.add(ceiling);

    // ---------- puertas cada 5 metros ----------
    // colocamos puertas en ambas paredes, inicio a 2.5m, luego +5m (por tanto posiciones a z = -7.5, -2.5, 2.5, 7.5 ?)
    // para un corridor de 20m, colocamos puertas centradas cada 5m empezando desde z = - (L/2) + 2.5
    const doorInterval = 50.0;
    const doorPositionsZ = [];
    for (let z = -corridorLength / 2 + doorInterval / 2; z < corridorLength / 2 + 0.0001; z += doorInterval) {
      doorPositionsZ.push(parseFloat(z.toFixed(6)));
    }

    // puerta como marco sencillo (ancho 0.9m, alto 2.0m, profundidad 0.05)
    const doorWidth = 9;
    const doorHeight = 20.0;
    const doorDepth = 0.5;
    const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, metalness: 0.05, roughness: 0.6 });

    doorPositionsZ.forEach((zpos) => {
      // lado derecho (pared x = +width/2)
      const rightDoorGeo = new THREE.BoxGeometry(doorDepth, doorHeight, doorWidth);
      const rightDoor = new THREE.Mesh(rightDoorGeo, woodMat);
      //rightDoor.rotation.y = Math.PI/2;
      rightDoor.position.set(corridorWidth / 2 + wallThickness / 2 + doorDepth / 2 - 0.5, doorHeight / 2, zpos);
      scene.add(rightDoor);

      // lado izquierdo (pared x = -width/2)
      const leftDoorGeo = new THREE.BoxGeometry(doorDepth, doorHeight, doorWidth);
      const leftDoor = new THREE.Mesh(leftDoorGeo, woodMat);
      //leftDoor.rotation.y = -Math.PI/2;
      leftDoor.position.set(-corridorWidth / 2 - wallThickness / 2 - doorDepth / 2 + 0.5, doorHeight / 2, zpos);
      scene.add(leftDoor);
    });


    ///////////////////// Robots

    const n_bots = 10;
    const robots = [];

    const beat = 1;
    const n_beats = 5;
    const tiempo = n_beats * beat;
    const d = 1;
    const R = 2.5;
    const omega = Math.PI / tiempo;
    const vel_lin = omega * R;

    for (let i = 0; i < n_bots; i++) {
      const robot = new Robot(scene, { x: (i - n_bots / 2) * 5, y: 0 });
      robots.push(robot);
    }
function set_sequences(){
    for (let i = 0; i < n_bots; i++) {
      robot=robots[i]
      if (i % 2 == 0) {
        robot.setSequence([
          { v: 1, w: 0, alpha0: 0, time: 2 },
          { v: 0, w: -Math.PI / 4, alpha0: -Math.PI / 2, alpha1: 0, time: 2 },
          { v: vel_lin, w: omega, time: tiempo },
          {
            v: 0,
            w: 0,
            alpha0: Math.PI / 2,
            alpha1: (6 * Math.PI) / 16,
            alpha2: -(6 * Math.PI) / 16,
            time: 2,
          },
          { v: -vel_lin, w: omega, time: tiempo },
        ]);
      } else {
        robot.setSequence([
          { v: 1, w: 0, alpha0: 0, time: 2 },
          {
            v: 0,
            w: -Math.PI / 4,
            alpha0: Math.PI / 2,
            alpha1: (6 * Math.PI) / 16,
            alpha2: -(6 * Math.PI) / 16,
            time: 2,
          },
          { v: -vel_lin, w: omega, time: tiempo },
          { v: 0, w: 0, alpha0: -Math.PI / 2, alpha1: 0, alpha2: 0, time: 2 },
          { v: vel_lin, w: omega, time: tiempo },
        ]);
      }
      
    }
  }
    let lastTime = performance.now();
    const keys = {};
    selectedRobot = robots[0]
    updateCameraView()

    //camera2.position.set(0, 25, 25);
    //camera2.lookAt(0, 0, 0);


    ///////////// Teclados y Botones

    window.addEventListener("keydown", (e) => {
      keys[e.code] = true;
      if (e.code.startsWith("Digit")) {
        const idx = parseInt(e.code.replace("Digit", ""));
        if (robots[idx]) {
          selectedRobot = robots[idx];
          console.log(`Robot ${idx} seleccionado`);
        }
      }
      if (["KeyS", "KeyP", "KeyT", "KeyB"].includes(e.code)) {
        cameraMode = e.code.replace("Key", "");
        console.log(`Modo de cámara: ${cameraMode}`);
      }
    });

    window.addEventListener("keyup", (e) => {
      keys[e.code] = false;
    });


    ////////////// Animación  
    const cameraSpeed = 0.01;
    const rotationSpeed = 0.002;

    animate();
    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;

      handleCameraControls();
      for (const robot of robots) robot.update(deltaTime);

      updateCameraView();
      renderer1.render(scene, camera1);//Global
      renderer2.render(scene, camera2);//Carro
    }

    //////////////7 Help Func

    function selectRobot(idx) {
      if (robots[idx]) {
        selectedRobot = robots[idx];
        console.log("Robot " + idx + " selected");
      }
    }

    function setCameraMode(mode) {
      cameraMode = mode;
      console.log("Camera mode " + mode);
    }

    function updateCameraView() {
      if (!selectedRobot) return;
      const target = selectedRobot.group.position.clone();

      switch (cameraMode) {
        case "S":
          camera2.position.set(target.x, 10, target.z);
          camera2.lookAt(target);
          break;
        case "P": {
          const dir = new THREE.Vector3(
            Math.cos(selectedRobot.state.beta),
            0,
            -Math.sin(selectedRobot.state.beta)
          );

          // posición de los "ojos" del robot
          const eye = target.clone().add(new THREE.Vector3(0, 1.5, 0)).add(dir.multiplyScalar(.3));

          // hacia dónde mira (un poco hacia abajo)
          const lookAt = eye.clone()
            .add(dir)            // adelante
            .add(new THREE.Vector3(0, -0.07, 0)); // bajamos 0.2 en Y

          camera2.position.copy(eye);
          camera2.lookAt(lookAt);
          break;
        }

        case "T": {
          const dir = new THREE.Vector3(
            Math.cos(selectedRobot.state.beta),
            0,
            -Math.sin(selectedRobot.state.beta)
          );
          const eye = target
            .clone()
            .add(new THREE.Vector3(0, 2, 0))
            .sub(dir.multiplyScalar(5));
          camera2.position.copy(eye);
          camera2.lookAt(target.clone().add(new THREE.Vector3(0, 1, 0)));
          break;
        }
        case "B": {
          camera2.position.x =
            Math.cos(
              selectedRobot.armBase.rotation.y +
              selectedRobot.base.rotation.y
            ) * 2;
          camera2.position.z =
            Math.sin(
              selectedRobot.armBase.rotation.y +
              selectedRobot.base.rotation.y
            ) * 2;
          camera2.position.y = selectedRobot.armBase.position.y + 2;
          camera2.lookAt(
            selectedRobot.armBase.getWorldPosition(new THREE.Vector3())
          );
          break;
        }
      }
    }

    function coreografia(){
      music.volume = 0.7;
      music.currentTime = 0; 
      music.play().then(() => {
        console.log("Música iniciada");
        console.log("🎵 Duración total:", music.duration, "segundos");
      }).catch(err => console.warn("Error al reproducir:", err));
      setTimeout(() => music.pause(), 16000);
      set_sequences()
    }

    function handleCameraControls() {
      if (keys["KeyW"]) {
        camera1.position.x -= Math.sin(camera1.rotation.y) * cameraSpeed;
        camera1.position.z -= Math.cos(camera1.rotation.y) * cameraSpeed;
      }
      if (keys["KeyS"]) {
        camera1.position.x += Math.sin(camera1.rotation.y) * cameraSpeed;
        camera1.position.z += Math.cos(camera1.rotation.y) * cameraSpeed;
      }
      if (keys["KeyA"]) {
        camera1.position.x -= Math.cos(camera1.rotation.y) * cameraSpeed;
        camera1.position.z += Math.sin(camera1.rotation.y) * cameraSpeed;
      }
      if (keys["KeyD"]) {
        camera1.position.x += Math.cos(camera1.rotation.y) * cameraSpeed;
        camera1.position.z -= Math.sin(camera1.rotation.y) * cameraSpeed;
      }
      if (keys["ArrowLeft"]) camera1.rotation.y += rotationSpeed;
      if (keys["ArrowRight"]) camera1.rotation.y -= rotationSpeed;
      if (keys["ArrowUp"]) camera1.rotation.x += rotationSpeed;
      if (keys["ArrowDown"]) camera1.rotation.x -= rotationSpeed;
      if (keys["KeyI"]) camera1.position.y += cameraSpeed * 5;
      if (keys["KeyK"]) camera1.position.y -= cameraSpeed * 5;
      if (keys["KeyJ"]) camera1.position.x -= cameraSpeed;
      if (keys["KeyL"]) camera1.position.x += cameraSpeed;
    }



  </script>
</body>

</html>