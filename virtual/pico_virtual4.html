<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RPi Pico + MicroPython</title>

<style>
body {
    background:#1e1e1e;
    color:white;
    font-family:Arial;
    display:flex;
    gap:30px;
    padding:20px;
}

.board {
    background:#0b6b3a;
    width:260px;
    padding:15px;
    border-radius:20px;
}

.pins {
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:6px;
}

.pin {
    height:28px;
    border:none;
    border-radius:5px;
    cursor:pointer;
    background:#444;
    color:white;
    font-size:12px;
}

.pin.active {
    background:#00ff88;
    color:black;
}

textarea {
    width:400px;
    height:400px;
    background:#111;
    color:#00ff88;
    padding:10px;
    font-family:monospace;
}

button.run {
    margin-top:10px;
    padding:10px;
    cursor:pointer;
}
</style>
</head>
<body>

<div class="board">
    <h3>RPi Pico</h3>
    <div class="pins" id="pins"></div>
</div>

<div>
    <h3>MicroPython Code</h3>
    <textarea id="code">
#from machine import Pin
import time
import asyncio

led = Pin(0, Pin.OUT)
led.value(1)

test = Pin(5, Pin.OUT)
test.value(1)

#led.value(0)

def tick1(timer):
    print("Tick from timer", timer.timer_id)
    tim0.deinit()

tim1 = Timer(1)
tim1.init(period=7000, mode=Timer.ONE_SHOT, callback=tick1)    

def tick0(timer):
    print("Tick from timer", timer.timer_id)

tim0 = Timer(0)
tim0.init(period=1000, mode=Timer.PERIODIC, callback=tick0)

#time.sleep(10)
#await asyncio.sleep(10000)
print('chao')

#tim.deinit()
</textarea>
    <br>
    <button class="run" id="runBtn">Run</button>
</div>

<script type="module">
import { loadMicroPython } from "./micropython.mjs";

const mp = await loadMicroPython();

/* -------------------------
   JSON state model
-------------------------- */
let pinState = {};
for (let i = 0; i <= 27; i++) {
    pinState[i] = 0;
}

/* -------------------------
   Board Rendering
-------------------------- */
const pinContainer = document.getElementById("pins");

function renderPins() {
    document.querySelectorAll(".pin").forEach(btn => {
        const num = parseInt(btn.dataset.pin);
        btn.classList.toggle("active", pinState[num] === 1);
    });
}

for (let i = 0; i <= 27; i++) {
    const btn = document.createElement("button");
    btn.className = "pin";
    btn.innerText = "GP" + i;
    btn.dataset.pin = i;

    btn.onclick = () => {
        pinState[i] = pinState[i] ? 0 : 1;
        renderPins();
    };

    pinContainer.appendChild(btn);
}

/* -------------------------
   Expose JS function to MicroPython
-------------------------- */
globalThis.setPinFromPython = (pin, value) => {
    pinState[pin] = value;
    renderPins();
};


/* -------------------------
   Timer
-------------------------- */
  await mp.runPythonAsync(`
counter = 0

def timer_callback():
    global counter
    counter += 1
`);

  const timerFunc = mp.pyimport("__main__").timer_callback;

  setInterval(() => {
    timerFunc();
  }, 100);



/* -------------------------
   Inject Custom Pin class
-------------------------- */
await mp.runPython(`
import js

class Pin:
    OUT = 1
    IN = 0

    def __init__(self, number, mode):
        self.number = number
        self.mode = mode

    def value(self, v=None):
        if v is None:
            return 0
        else:
            import js
            js.setPinFromPython(self.number, v)

class PWM:
    def __init__(self, channel):
        self.reg = js.hw.PWM[f"CH{channel}"]

    def freq(self, f=None):
        if f is None:
            return self.reg.FREQ
        self.reg.FREQ = f

    def duty(self, d=None):
        if d is None:
            return self.reg.DUTY
        self.reg.DUTY = d

    def enable(self, state=True):
        self.reg.ENABLE = 1 if state else 0

class Timer:
    PERIODIC = 0
    ONE_SHOT = 1

    def __init__(self, timer_id=0):
        self.timer_id = timer_id
        self._interval_id = None
        self._callback = None
        self._mode = None
        self._period = None

    def init(self, *, period, mode=PERIODIC, callback):
        self.deinit()  # stop existing timer if running

        self._period = period
        self._mode = mode
        self._callback = callback

        def _wrapped():
            try:
                callback(self)
            except Exception as e:
                print("Timer callback error:", e)

            if self._mode == Timer.ONE_SHOT:
                self.deinit()

        if mode == Timer.PERIODIC:
            self._interval_id = js.setInterval(_wrapped, period)
        elif mode == Timer.ONE_SHOT:
            self._interval_id = js.setTimeout(_wrapped, period)
        else:
            raise ValueError("Invalid timer mode")

    def deinit(self):
        if self._interval_id is not None:
            try:
                js.clearInterval(self._interval_id)
            except:
                pass
            try:
                js.clearTimeout(self._interval_id)
            except:
                pass

        self._interval_id = None

`);

/* -------------------------
   Run user code
-------------------------- */
document.getElementById("runBtn").onclick = async () => {
    const code = document.getElementById("code").value;
    try {
        await mp.runPython(code);
    } catch (err) {
        console.error(err);
        alert(err);
    }
};

renderPins();
</script>

</body>
</html>